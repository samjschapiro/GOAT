import torch
import torch.nn as nn
import torch.nn.functional as F
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


def compute_sharpness(model_, perturbations, data, labels, weights=None):
    """ Given a model and the first-order optimal perturbations from the final batch, computes the sharpness of the model.
    """
    model = model_.copy()
    model.eval()

    # Convert perturbations and data to tensors
    perturbations = torch.tensor(perturbations)
    data = torch.tensor(data)

    # Ensure both perturbations and data are on the same device as the model
    perturbations = perturbations.to(next(model.parameters()).device)
    data = data.to(next(model.parameters()).device)

    # Get model outputs before perturbation
    outputs_bef = model(data)

    # Perturb model
    for name, param in model:
        param.add_(perturbations[name])

    # Get model outputs after perturbation
    outputs_aft = model(data)

    # Compute difference in loss
    if weights == None:
        loss = F.cross_entropy(outputs_bef, labels)
    else:
        criterion = nn.CrossEntropyLoss(reduction='none')
        loss = criterion(outputs_bef, labels)
        loss = (loss * weights).mean()

    # Compute difference in loss
    if weights == None:
        loss_aft = F.cross_entropy(outputs_aft, labels)
    else:
        criterion = nn.CrossEntropyLoss(reduction='none')
        loss_aft = criterion(outputs_aft, labels)
        loss_aft = (loss_aft * weights).mean()

    return loss - loss_aft

def compute_sharpness_sgd(model, perturbations, data):
    """ Gonna be harder...
    
    """
    pass